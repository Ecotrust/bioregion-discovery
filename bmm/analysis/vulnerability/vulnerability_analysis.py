#from django.http import HttpResponse
from django.shortcuts import render_to_response#, get_object_or_404
from django.template import RequestContext
from lingcod.raster_stats.models import RasterDataset, zonal_stats
from lingcod.unit_converter.models import convert_float_to_area_display_units
from analysis.utils import convert_sq_km_to_sq_mi, convert_cm_to_in, get_terra_geom, get_oceanic_geom
from analysis.caching.report_caching import *
from analysis.models import ExtinctLanguages
#from settings import *

default_value = '---'
uw5_total = 158342000.
u5_total = 642000000.
worlds_population = 7000000000.
sea_level_grid_size = 858.8379471 * 858.8379471

'''
Run the analysis, create the cache, and return the results as a context dictionary so they may be rendered with template
'''    
def display_climate_analysis(request, bioregion, template='vulnerability/climate_report.html'):
    #get human vulnerabilities to climate change
    climate_impact = get_climate_change_vulnerability(bioregion)
    #get impact on water resources
    water_impact = get_water_impact(bioregion)
    #get anticipated land loss due to sea level rise (1m, 3m, 6m)
    land_loss_1m, land_loss_3m, land_loss_6m = get_sea_rise_impacts(bioregion)
    #compile context
    context = {'bioregion': bioregion, 'default_value': default_value, 'climate_impact': climate_impact, 'water_impact': water_impact, 'land_loss_1m': land_loss_1m, 'land_loss_3m': land_loss_3m, 'land_loss_6m': land_loss_6m}
    return render_to_response(template, RequestContext(request, context)) 
    
'''
Run the analysis, create the cache, and return the results as a context dictionary so they may be rendered with template
'''    
def display_socioeconomic_analysis(request, bioregion, template='vulnerability/socioeconomic_report.html'):
    #get human influence index (HII)  (0-64, low to high) -- area of land developed
    human_influence = get_human_influence(bioregion) #50 seconds
    #get human consumption (HANPP - Human Appropriation of Net Primary Productivity)
    #represents regions in which human consumption is greatly in excess of local ecosystems
    human_consumption = get_human_consumption(bioregion) #2 seconds
    #get global impact of marine ecosystems
    marine_impacts = get_marine_ecosystem_impacts(bioregion) #15 seconds
    #get human presence (built up land - light signatures and landuse) (0-100, low to high)
    #human_presence = get_human_presence(bioregion)
    #get soil suitability
    soil_suitability = get_soil_suitability(bioregion) #1 second 
    #get water stress (ration of human water use to renewable water resources)
    rws_index, rws_rating = get_water_stress(bioregion) #2 seconds 
    #get infant deaths
    #infant_deaths = get_infant_deaths(bioregion)
    #get underweight children (number of underweight children under the age of 5)
    underweight_children = get_underweight_children(bioregion) #7 seconds
    #perc_underweight_children = underweight_children / uw5_total #this value is the sum total of all underweight children 
    perc_impoverished = uw5_total / u5_total #(total uw5 / total <5)
    #estimated_impoverished = perc_underweight_children * perc_impoverished * worlds_population
    estimated_impoverished = perc_impoverished * worlds_population
    #report out a 'No Data' if estimated_impoverished is 0.0
    #percentage of population    
    population_2005 = get_population(bioregion) #7 seconds 
    perc_population = population_2005 / worlds_population
    #get extinct languages
    extinct_languages = get_extinct_languages(bioregion) #1 second 
    #compile context
    context = {'bioregion': bioregion, 'default_value': default_value, 'underweight_children': underweight_children, 'perc_underweight_children': perc_underweight_children, 'estimated_impoverished': estimated_impoverished, 'perc_population': perc_population, 'human_consumption': human_consumption, 'human_influence': human_influence, 'marine_impacts': marine_impacts, 'soil_suitability': soil_suitability, 'rws_index': rws_index, 'rws_rating': rws_rating, 'extinct_languages': extinct_languages}
    return render_to_response(template, RequestContext(request, context)) 
      
'''
Run the analysis, create the cache, and return the results as a context dictionary so they may be rendered with template
'''    
def display_hazards_analysis(request, bioregion, template='vulnerability/hazards_report.html'):
    #hazrd codes:  drgt: drought, fld: flood, vol: volcano, pga: earthquake, cyc: cyclone, lnd: landslide
    #hzrd_xxx for frequency and distribution, xxx_gdp for economic impact 
    #get likely and unlikely hazards
    likely_hazards, unlikely_hazards = get_hazard_lists(bioregion)
    #compile context
    context = {'bioregion': bioregion, 'default_value': default_value, 'likely_hazards': likely_hazards, 'unlikely_hazards': unlikely_hazards}
    return render_to_response(template, RequestContext(request, context)) 

def get_climate_change_vulnerability(bioregion):
    cc_geom = RasterDataset.objects.get(name='climate_impact')
    cc_stats = zonal_stats(bioregion.output_geom, cc_geom)
    if cc_stats.avg < -12: return 'Low'
    if cc_stats.avg < -4: return 'Moderately Low'
    if cc_stats.avg < 4: return 'Moderate'
    if cc_stats.avg < 12: return 'Moderately High'
    else: return 'High'
    
def get_water_impact(bioregion):
    wi_geom = RasterDataset.objects.get(name='water_impact')
    wi_stats = zonal_stats(bioregion.output_geom, wi_geom)
    wi_avg = wi_stats.avg
    if wi_avg < 1: return 'Less'
    elif wi_avg > 1: return 'More'
    else: return 'No Change in'
    
def get_sea_rise_impacts(bioregion):
    terra_geom = get_terra_geom(bioregion)
    s1_geom = RasterDataset.objects.get(name='sea_rise_1m')
    s3_geom = RasterDataset.objects.get(name='sea_rise_3m')
    s6_geom = RasterDataset.objects.get(name='sea_rise_6m')
    s1_stats = zonal_stats(terra_geom, s1_geom)
    s3_stats = zonal_stats(terra_geom, s3_geom)
    s6_stats = zonal_stats(terra_geom, s6_geom)
    land_loss_1m = s1_stats.sum * sea_level_grid_size
    land_loss_3m = s3_stats.sum * sea_level_grid_size
    land_loss_6m = s6_stats.sum * sea_level_grid_size
    land_loss_1m_km = round(convert_float_to_area_display_units(land_loss_1m), 1)
    land_loss_1m_mi = round(convert_sq_km_to_sq_mi(land_loss_1m_km), 1)
    land_loss_3m_km = round(convert_float_to_area_display_units(land_loss_3m), 1)
    land_loss_3m_mi = round(convert_sq_km_to_sq_mi(land_loss_3m_km), 1)
    land_loss_6m_km = round(convert_float_to_area_display_units(land_loss_6m), 1)
    land_loss_6m_mi = round(convert_sq_km_to_sq_mi(land_loss_6m_km), 1)
    return (land_loss_1m_km, land_loss_1m_mi), (land_loss_3m_km, land_loss_3m_mi), (land_loss_6m_km, land_loss_6m_mi)
    
def get_human_consumption(bioregion):
    hc_geom = RasterDataset.objects.get(name='human_consumption')
    hc_stats = zonal_stats(bioregion.output_geom, hc_geom)
    return int(hc_stats.avg)
    
def get_marine_ecosystem_impacts(bioregion):
    oceanic_geom = get_oceanic_geom(bioregion)
    if oceanic_geom.area == 0:
        return 0
    mi_geom = RasterDataset.objects.get(name='ocean_impact')
    mi_stats = zonal_stats(oceanic_geom, mi_geom)
    return round(mi_stats.avg, 1)
'''   
def get_human_presence(bioregion):
    hp_geom = RasterDataset.objects.get(name='human_presence')
    hp_stats = zonal_stats(bioregion.output_geom, hp_geom)
    return int(hp_stats.avg)
'''   
def get_human_footprint(bioregion):
    hf_geom = RasterDataset.objects.get(name='human_footprint')
    hf_stats = zonal_stats(bioregion.output_geom, hf_geom)
    return int(hf_stats.avg)
   
def get_human_influence(bioregion):
    hii_geom = RasterDataset.objects.get(name='human_influence_index')
    hii_stats = zonal_stats(bioregion.output_geom, hii_geom)
    return hii_stats.avg / 64
   
def get_water_stress(bioregion):
    ws_geom = RasterDataset.objects.get(name='water_stress')
    ws_stats = zonal_stats(bioregion.output_geom, ws_geom)
    rwsi = ws_stats.avg
    if rwsi >= .4:
        rating = 'High'
    elif rwsi >= .2:
        rating = 'Moderate'
    else:
        rating = 'Low'
    return rwsi, rating
   
def get_soil_suitability(bioregion):
    suit_geom = RasterDataset.objects.get(name='soil_suitability')
    suit_stats = zonal_stats(bioregion.output_geom, suit_geom)
    return suit_stats.avg
    
def get_infant_deaths(bioregion):
    id_geom = RasterDataset.objects.get(name='infant_deaths')
    id_stats = zonal_stats(bioregion.output_geom, id_geom)
    return int(id_stats.sum)
   
def get_underweight_children(bioregion):
    uwc_geom = RasterDataset.objects.get(name='underweight_children')
    uwc_stats = zonal_stats(bioregion.output_geom, uwc_geom)
    return int(uwc_stats.sum)

def get_population(bioregion):
    pop_geom = RasterDataset.objects.get(name='population_2005')
    pop_stats = zonal_stats(bioregion.output_geom, pop_geom)
    return int(pop_stats.sum)
    
def get_hazard_lists(bioregion):
    likely_hazards = []
    unlikely_hazards = []
    hazards = ['cyclone', 'drought', 'flood', 'landslide', 'earthquake', 'volcano']
    for hazard in hazards:
        cost = hazard_impact(hazard, bioregion)
        if hazard_is_likely(hazard, bioregion):
            likely_hazards.append((hazard.capitalize(), cost))
        else:
            unlikely_hazards.append((hazard.capitalize(), cost))
    likely_hazards.sort()
    unlikely_hazards.sort()
    return likely_hazards, unlikely_hazards
            
def hazard_impact(hazard, bioregion):
    hzd_gdp_geom = RasterDataset.objects.get(name=hazard+'_impact')
    hzd_gdp_stats = zonal_stats(bioregion.output_geom, hzd_gdp_geom)
    if hzd_gdp_stats.sum > 0:
        return 'High'
    else:
        return 'Low'
        
def hazard_is_likely(hazard, bioregion):
    hzd_geom = RasterDataset.objects.get(name=hazard)
    hzd_stats = zonal_stats(bioregion.output_geom, hzd_geom)
    if hzd_stats.sum > 0:
        return True
    else:
        return False
        
def get_extinct_languages(bioregion):
    if report_cache_exists(bioregion, 'extinct_languages'):
        lang_tuples = get_report_cache(bioregion, 'extinct_languages')
        return lang_tuples
    else:
        languages = ExtinctLanguages.objects.all()
        lang_tuples = [(lang.nam_ansi, int(lang.lmp_pop1)) for lang in languages if lang.geometry.intersects(bioregion.output_geom)]
        lang_tuples.sort()
        create_report_cache(bioregion, dict(extinct_languages=lang_tuples))
        return lang_tuples    

   