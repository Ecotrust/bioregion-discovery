#from django.http import HttpResponse
from django.shortcuts import render_to_response#, get_object_or_404
from django.template import RequestContext
from lingcod.raster_stats.models import RasterDataset, zonal_stats
from lingcod.unit_converter.models import convert_float_to_area_display_units
from analysis.utils import convert_sq_km_to_sq_mi, convert_cm_to_in, get_terra_geom, get_oceanic_geom
from analysis.caching.report_caching import *
from analysis.models import ExtinctLanguages, SeaRise1m, SeaRise3m, SeaRise6m
#from settings import *

default_value = '---'
uw5_total = 115000000. #http://www.who.int/whosis/whostat/EN_WHS2011_Part1.pdf 
u5_total = 642000000.
worlds_population = 7000000000.
worlds_population_in_poverty = 1700000000.
sea_level_grid_size = 858.8379471 * 858.8379471

'''
Run the analysis, create the cache, and return the results as a context dictionary so they may be rendered with template
'''    
def display_climate_analysis(request, bioregion, template='vulnerability/climate_report.html'):
    #get human vulnerabilities to climate change
    climate_impact = get_climate_change_vulnerability(bioregion)
    #get impact on water resources
    water_impact = get_water_impact(bioregion)
    #get anticipated land loss due to sea level rise (1m, 3m, 6m)
    land_loss_1m, land_loss_3m, land_loss_6m = get_sea_rise_impacts(bioregion)
    #get affected people due to sea level rise
    displaced_pop_1m, displaced_pop_3m, displaced_pop_6m = get_displaced_populations(bioregion)
    #compile context
    context = {'bioregion': bioregion, 'default_value': default_value, 'climate_impact': climate_impact, 'water_impact': water_impact, 'land_loss_1m': land_loss_1m, 'land_loss_3m': land_loss_3m, 'land_loss_6m': land_loss_6m, 'displaced_pop_1m': displaced_pop_1m, 'displaced_pop_3m': displaced_pop_3m, 'displaced_pop_6m': displaced_pop_6m}
    return render_to_response(template, RequestContext(request, context)) 
    
'''
Run the analysis, create the cache, and return the results as a context dictionary so they may be rendered with template
'''    
def display_socioeconomic_analysis(request, bioregion, template='vulnerability/socioeconomic_report.html'):
    #get human influence index (HII)  (0-64, low to high) -- area of land developed
    human_influence = get_human_influence(bioregion) #50 seconds
    #get human consumption (HANPP - Human Appropriation of Net Primary Productivity)
    #represents regions in which human consumption is greatly in excess of local ecosystems
    human_consumption = get_human_consumption(bioregion) #2 seconds
    #get global impact of marine ecosystems
    marine_impacts = get_marine_ecosystem_impacts(bioregion) #15 seconds
    #get human presence (built up land - light signatures and landuse) (0-100, low to high)
    #human_presence = get_human_presence(bioregion)
    #get soil suitability
    soil_suitability = get_soil_suitability(bioregion) #1 second 
    #get water stress (ration of human water use to renewable water resources)
    rws_index, rws_rating = get_water_stress(bioregion) #2 seconds 
    #percentage of population    
    population_2005 = get_population(bioregion) #7 seconds 
    #get infant deaths
    #infant_deaths = get_infant_deaths(bioregion)
    #get underweight children (number of underweight children under the age of 5)
    underweight_children = get_underweight_children(bioregion) #7 seconds
    perc_underweight_children = underweight_children / uw5_total #this value is the sum total of all underweight children 
    #perc_impoverished = uw5_total / u5_total #(total uw5 / total <5)
    #estimated_impoverished = perc_underweight_children * perc_impoverished * worlds_population
    if perc_underweight_children > 0:
        estimated_impoverished = perc_underweight_children * worlds_population_in_poverty
    else:
        estimated_impoverished = 0
    estimated_perc_impoverished = estimated_impoverished / population_2005
    #report out a 'No Data' if estimated_impoverished is 0.0
    #get extinct languages
    extinct_languages = get_extinct_languages(bioregion) #1 second 
    #compile context
    context = {'bioregion': bioregion, 'default_value': default_value, 'underweight_children': underweight_children, 'perc_underweight_children': perc_underweight_children, 'estimated_impoverished': estimated_impoverished, 'estimated_perc_impoverished': estimated_perc_impoverished, 'human_consumption': human_consumption, 'human_influence': human_influence, 'marine_impacts': marine_impacts, 'soil_suitability': soil_suitability, 'rws_index': rws_index, 'rws_rating': rws_rating, 'extinct_languages': extinct_languages}
    return render_to_response(template, RequestContext(request, context)) 
      
'''
Run the analysis, create the cache, and return the results as a context dictionary so they may be rendered with template
'''    
def display_hazards_analysis(request, bioregion, template='vulnerability/hazards_report.html'):
    #hazrd codes:  drgt: drought, fld: flood, vol: volcano, pga: earthquake, cyc: cyclone, lnd: landslide
    #hzrd_xxx for frequency and distribution, xxx_gdp for economic impact 
    #get likely and unlikely hazards
    likely_hazards, unlikely_hazards = get_hazard_lists(bioregion)
    #compile context
    context = {'bioregion': bioregion, 'default_value': default_value, 'likely_hazards': likely_hazards, 'unlikely_hazards': unlikely_hazards}
    return render_to_response(template, RequestContext(request, context)) 

def get_climate_change_vulnerability(bioregion):
    cc_geom = RasterDataset.objects.get(name='climate_impact')
    cc_stats = zonal_stats(bioregion.output_geom, cc_geom)
    if cc_stats.avg < -12: index = 'Low'
    elif cc_stats.avg < -4: index = 'Moderately Low'
    elif cc_stats.avg < 4: index = 'Moderate'
    elif cc_stats.avg < 12: index = 'Moderately High'
    else: index = 'High'
    return (index, cc_stats.avg)
    
def get_water_impact(bioregion):
    wi_geom = RasterDataset.objects.get(name='water_impact')
    wi_stats = zonal_stats(bioregion.output_geom, wi_geom)
    wi_avg = wi_stats.avg
    if wi_avg < 1: return 'Less'
    elif wi_avg > 1: return 'More'
    else: return 'No Change in'
    
def get_sea_rise_impacts(bioregion):
    terra_geom = get_terra_geom(bioregion)
    s1_geom = RasterDataset.objects.get(name='sea_rise_1m')
    s3_geom = RasterDataset.objects.get(name='sea_rise_3m')
    s6_geom = RasterDataset.objects.get(name='sea_rise_6m')
    s1_stats = zonal_stats(terra_geom, s1_geom)
    s3_stats = zonal_stats(terra_geom, s3_geom)
    s6_stats = zonal_stats(terra_geom, s6_geom)
    land_loss_1m = s1_stats.sum * sea_level_grid_size
    land_loss_3m = s3_stats.sum * sea_level_grid_size
    land_loss_6m = s6_stats.sum * sea_level_grid_size
    land_loss_1m_km = int(convert_float_to_area_display_units(land_loss_1m))
    land_loss_1m_mi = int(convert_sq_km_to_sq_mi(land_loss_1m_km))
    land_loss_3m_km = int(convert_float_to_area_display_units(land_loss_3m))
    land_loss_3m_mi = int(convert_sq_km_to_sq_mi(land_loss_3m_km))
    land_loss_6m_km = int(convert_float_to_area_display_units(land_loss_6m))
    land_loss_6m_mi = int(convert_sq_km_to_sq_mi(land_loss_6m_km))
    return (land_loss_1m_km, land_loss_1m_mi), (land_loss_3m_km, land_loss_3m_mi), (land_loss_6m_km, land_loss_6m_mi)
    
def get_displaced_populations(bioregion):
    pop_geom = RasterDataset.objects.get(name='population_2005')
    pop_stats = zonal_stats(bioregion.output_geom, pop_geom)
    pop_05 = pop_stats.sum
    if report_cache_exists(bioregion, 'displaced_people_1m'):
        displaced_1m = get_report_cache(bioregion, 'displaced_people_1m')
    else:
        sr_1m = SeaRise1m.objects.filter(geometry__bboverlaps=bioregion.output_geom)  #.aggregate(Collect('geometry'))
        sr_1m_geoms = [sr.geometry for sr in sr_1m if sr.geometry.intersects(bioregion.output_geom)]
        sum_1m = 0
        for sr_geom in sr_1m_geoms:
            pop_stats = zonal_stats(sr_geom, pop_geom)
            if pop_stats and pop_stats.sum:
                sum_1m += pop_stats.sum
        perc_1m = sum_1m / pop_05
        sum_1m = int(sum_1m / 1000) * 1000
        displaced_1m = (sum_1m, perc_1m)
        create_report_cache(bioregion, dict(displaced_people_1m=displaced_1m))
    
    if report_cache_exists(bioregion, 'displaced_people_3m'):
        displaced_3m = get_report_cache(bioregion, 'displaced_people_3m')
    else:
        sr_3m = SeaRise3m.objects.filter(geometry__bboverlaps=bioregion.output_geom)  #.aggregate(Collect('geometry'))
        sr_3m_geoms = [sr.geometry for sr in sr_3m if sr.geometry.intersects(bioregion.output_geom)]
        sum_3m = 0
        for sr_geom in sr_3m_geoms:
            pop_stats = zonal_stats(sr_geom, pop_geom)
            if pop_stats and pop_stats.sum:
                sum_3m += pop_stats.sum
        perc_3m = sum_3m / pop_05
        sum_3m = int(sum_3m / 1000) * 1000
        displaced_3m = (sum_3m, perc_3m)
        create_report_cache(bioregion, dict(displaced_people_3m=displaced_3m))
    
    if report_cache_exists(bioregion, 'displaced_people_6m'):
        displaced_6m = get_report_cache(bioregion, 'displaced_people_6m')
    else:
        sr_6m = SeaRise6m.objects.filter(geometry__bboverlaps=bioregion.output_geom)  #.aggregate(Collect('geometry'))
        sr_6m_geoms = [sr.geometry for sr in sr_6m if sr.geometry.intersects(bioregion.output_geom)]
        sum_6m = 0
        for sr_geom in sr_6m_geoms:
            pop_stats = zonal_stats(sr_geom, pop_geom)
            if pop_stats and pop_stats.sum:
                sum_6m += pop_stats.sum
        perc_6m = sum_6m / pop_05
        sum_6m = int(sum_6m / 1000) * 1000
        displaced_6m = (sum_6m, perc_6m)
        create_report_cache(bioregion, dict(displaced_people_6m=displaced_6m))
        
    return displaced_1m, displaced_3m, displaced_6m
    
    
    
def get_human_consumption(bioregion):
    hc_geom = RasterDataset.objects.get(name='human_consumption')
    hc_stats = zonal_stats(bioregion.output_geom, hc_geom)
    return int(hc_stats.avg)
    
def get_marine_ecosystem_impacts(bioregion):
    oceanic_geom = get_oceanic_geom(bioregion)
    if oceanic_geom.area == 0:
        return 0
    mi_geom = RasterDataset.objects.get(name='ocean_impact')
    mi_stats = zonal_stats(oceanic_geom, mi_geom)
    avg = round(mi_stats.avg, 1)
    if avg < 1.4:
        impact = 'Very Low'
    elif avg < 4.95:
        impact = 'Low'
    elif avg < 8.47:
        impact = 'Medium'
    elif avg < 12:
        impact = 'Medium High'
    elif avg < 15.52:
        impact = 'High'
    else:
        impact = 'Very High'
    return impact
'''   
def get_human_presence(bioregion):
    hp_geom = RasterDataset.objects.get(name='human_presence')
    hp_stats = zonal_stats(bioregion.output_geom, hp_geom)
    return int(hp_stats.avg)
''' 
'''  
def get_human_footprint(bioregion):
    hf_geom = RasterDataset.objects.get(name='human_footprint')
    hf_stats = zonal_stats(bioregion.output_geom, hf_geom)
    return int(hf_stats.avg)
'''   
def get_human_influence(bioregion):
    hii_geom = RasterDataset.objects.get(name='human_influence_index')
    hii_stats = zonal_stats(bioregion.output_geom, hii_geom)
    return hii_stats.avg / 64
   
def get_water_stress(bioregion):
    ws_geom = RasterDataset.objects.get(name='water_stress')
    ws_stats = zonal_stats(bioregion.output_geom, ws_geom)
    rwsi = ws_stats.avg
    if rwsi >= .4:
        rating = 'High'
    elif rwsi >= .2:
        rating = 'Moderate'
    else:
        rating = 'Low'
    return rwsi, rating
   
def get_soil_suitability(bioregion):
    suit_geom = RasterDataset.objects.get(name='soil_suitability')
    suit_stats = zonal_stats(bioregion.output_geom, suit_geom)
    return suit_stats.avg
    
def get_infant_deaths(bioregion):
    id_geom = RasterDataset.objects.get(name='infant_deaths')
    id_stats = zonal_stats(bioregion.output_geom, id_geom)
    return int(id_stats.sum)
   
def get_underweight_children(bioregion):
    uwc_geom = RasterDataset.objects.get(name='underweight_children')
    uwc_stats = zonal_stats(bioregion.output_geom, uwc_geom)
    return int(uwc_stats.sum)

def get_population(bioregion):
    pop_geom = RasterDataset.objects.get(name='population_2005')
    pop_stats = zonal_stats(bioregion.output_geom, pop_geom)
    return int(pop_stats.sum)
    
def get_hazard_lists(bioregion):
    likely_hazards = []
    unlikely_hazards = []
    hazards = ['cyclone', 'drought', 'flood', 'landslide', 'earthquake', 'volcano']
    for hazard in hazards:
        cost = hazard_impact(hazard, bioregion)
        if hazard_is_likely(hazard, bioregion):
            likely_hazards.append((hazard.capitalize(), cost))
        else:
            unlikely_hazards.append((hazard.capitalize(), cost))
    likely_hazards.sort()
    unlikely_hazards.sort()
    return likely_hazards, unlikely_hazards
            
def hazard_impact(hazard, bioregion):
    hzd_gdp_geom = RasterDataset.objects.get(name=hazard+'_impact')
    hzd_gdp_stats = zonal_stats(bioregion.output_geom, hzd_gdp_geom)
    if hzd_gdp_stats.sum > 0:
        return 'High'
    else:
        return 'Low'
        
def hazard_is_likely(hazard, bioregion):
    hzd_geom = RasterDataset.objects.get(name=hazard)
    hzd_stats = zonal_stats(bioregion.output_geom, hzd_geom)
    if hzd_stats.sum > 0:
        return True
    else:
        return False
        
def get_extinct_languages(bioregion):
    if report_cache_exists(bioregion, 'extinct_languages'):
        lang_tuples = get_report_cache(bioregion, 'extinct_languages')
        return lang_tuples
    else:
        languages = ExtinctLanguages.objects.all()
        lang_tuples = [(lang.nam_ansi, int(lang.lmp_pop1)) for lang in languages if lang.geometry.intersects(bioregion.output_geom)]
        lang_tuples.sort()
        create_report_cache(bioregion, dict(extinct_languages=lang_tuples))
        return lang_tuples    

   